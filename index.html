<!DOCTYPE html>
<html>
	<head>
		<title>BPNN</title>
		<script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
		<style>

			body, html
			{
				position:absolute;
				top:0px;
				left:0px;
				width:100%;
				height:100%;
				
				margin:0px;
				padding:0px;
				border:0px;
				
				background:#777;
				overflow:hidden;
			}
			
			#GridH
			{
				position:absolute;
				top:50%;
				left:0%;
				width:100%;
				height:100px;
				
				border-top:1px dashed #ccc;
			}
			#GridV
			{
				position:absolute;
				top:0%;
				left:50%;
				width:100px;
				height:100%;
				
				border-left:1px dashed #ccc;
			}
			
			#Neurons, #TrainingVectors, #Networks
			{
				position:absolute;
				top:50%;
				left:50%;
			}
			
			#Neurons
			{
				display:none;
			}
			
			#Neurons .Container
			{
				position:absolute;
				left:0px;
				top:0px;
				width:0px;
				height:0px;
			}
			#Neurons .Container .Bias
			{
				position:absolute;
				top:-2px;
				left:0px;
				border-top:3px dotted #ccc;
			}
			#Neurons .Container .Line
			{
				position:absolute;
				top:-500px;
				left:0px;
				width:0px;
				height:1000px;
				border-left:2px solid #fff;
				border-right:2px solid #000;
			}
			
			#TrainingVectors .Container
			{
				display:block;
				position:absolute;
				width:0px;
				height:0px;
			}
			#TrainingVectors .Container .Offset
			{
				position:absolute;
				top:-4px;
				left:-4px;
				width:8px;
				height:8px;
				
				background:#F00;
				cursor:pointer;
				border-radius:5px;
				border:1px solid #000;
				box-shadow:0px 0px 10px #fff;
			}
			#TrainingVectors .TypeA .Offset
			{
				background:#F00;
			}
			#TrainingVectors .TypeB .Offset
			{
				background:#0F0;
			}
			#TrainingVectors .TypeC .Offset
			{
				background:#00F;
			}
			
		</style>
	</head>
	<body>
		<div id="Networks"></div>
		<div id="Neurons"></div>
		<div id="GridH"></div>
		<div id="GridV"></div>
		<div id="TrainingVectors"></div>
	</body>



<!-- training vector -->
<script>
var TrainingVector = {};
TrainingVector.Instances = [];
TrainingVector.Create = function(inPos, inType)
{
	var obj = {};

	obj.Pos = inPos;
	obj.Type = inType;
	obj.Error = 0;
	
	TrainingVector.Instances.push(obj);
	return obj;
};
</script>
<!-- training vector vizualizer -->
<script>
var TrainingVectorViz = {};
TrainingVectorViz.JQ = {};
TrainingVectorViz.JQ.Container = $("#TrainingVectors");
TrainingVectorViz.JQ.Document = $(document); 
TrainingVectorViz.CSS = {};
TrainingVectorViz.CSS.ClassContainer = "Container";
TrainingVectorViz.CSS.ClassOffset = "Offset";
TrainingVectorViz.Instances = [];

TrainingVectorViz.Create = function(inTrainingVector, inCSSClass)
{
	var obj = {};
	
	obj.TrainingVector = inTrainingVector;
	
	obj.JQ = {};
	obj.JQ.Container = $("<div class=\""+TrainingVectorViz.CSS.ClassContainer+" "+inCSSClass+"\"></div>");
	obj.JQ.Offset = $("<div class=\""+TrainingVectorViz.CSS.ClassOffset+"\"></div>");
	
	obj.Mouse = {};
	obj.Mouse.OldX = 0;
	obj.Mouse.NewX = 0;
	obj.Mouse.OldY = 0;
	obj.Mouse.NewY = 0;
	
	obj.Handlers = {};
	obj.Handlers.MouseDown = function(e)
	{
		obj.Mouse.NewX = e.pageX;
		obj.Mouse.NewY = e.pageY;		
	
		obj.JQ.Container.unbind("mousedown", obj.Handlers.MouseDown);
		TrainingVectorViz.JQ.Document.bind("mousemove", obj.Handlers.MouseMove);
		TrainingVectorViz.JQ.Document.bind("mouseup", obj.Handlers.MouseUp);
	};
	obj.Handlers.MouseMove = function(e)
	{
		obj.Mouse.OldX = obj.Mouse.NewX;
		obj.Mouse.OldY = obj.Mouse.NewY;
		
		obj.Mouse.NewX = e.pageX;
		obj.Mouse.NewY = e.pageY;
		
		obj.TrainingVector.Pos[0] += obj.Mouse.NewX - obj.Mouse.OldX;
		obj.TrainingVector.Pos[1] += obj.Mouse.NewY - obj.Mouse.OldY;
		TrainingVectorViz.Update(obj);
	};
	obj.Handlers.MouseUp = function(e)
	{
		TrainingVectorViz.JQ.Document.unbind("mousemove", obj.Handlers.MouseMove);
		TrainingVectorViz.JQ.Document.unbind("mouseup", obj.Handlers.MouseUp);
		obj.JQ.Container.bind("mousedown", obj.Handlers.MouseDown);
	};
	obj.Handlers.MouseUp();
	
	obj.JQ.Container.append(obj.JQ.Offset);
	TrainingVectorViz.JQ.Container.append(obj.JQ.Container);
	TrainingVectorViz.Instances.push(obj);
	TrainingVectorViz.Update(obj);
	return obj;
};
TrainingVectorViz.Update = function(inTrainingVectorViz)
{
	inTrainingVectorViz.JQ.Container.css({left:(inTrainingVectorViz.TrainingVector.Pos[0])+"px", top:(inTrainingVectorViz.TrainingVector.Pos[1])+"px"});
};
</script>



<!-- neuron -->
<script>
var Neuron = {};
Neuron.Utilities = {};
Neuron.Utilities.Observe = function(inNeuron, inInputs)
{
	var i = 0;
	var sum = 0;
	inNeuron.Model.Inputs = inInputs;
	for(i=0; i<inNeuron.Model.WeightsNormalized.length; i++)
	{
		sum += inNeuron.Model.WeightsNormalized[i] * inNeuron.Model.Inputs[i];
	}
	inNeuron.Outputs.Linear = sum - inNeuron.Model.Bias;
	
	inNeuron.Outputs.Sigmoid = 	1 / (1+Math.pow(2, -inNeuron.Outputs.Linear));
	inNeuron.Outputs.SigmoidDeriv = inNeuron.Outputs.Sigmoid * (1 - inNeuron.Outputs.Sigmoid);
	
	if(inNeuron.Outputs.Linear < 0)
		inNeuron.Outputs.Step = 0;
	else
		inNeuron.Outputs.Step = 1;
};
Neuron.Utilities.Normalize = function(inNeuron)
{
	var i;
	var length;
	
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		length += inNeuron.Model.Weights[i] * inNeuron.Model.Weights[i];
	}
	length = Math.sqrt(length);
	for(i=0; i<inNeuron.Model.WeightsNormalized.length; i++)
	{
		inNeuron.Model.WeightsNormalized[i] = inNeuron.Model.Weights[i]/length;
	}
};
Neuron.Utilities.Learn = function(inNeuron)
{
	var i =0;
	var sum = 0;
	var length = 0;

	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.Weights[i] += inNeuron.Learning.RateWeights * inNeuron.Learning.Error * inNeuron.Model.Inputs[i];
		sum += inNeuron.Model.Weights[i] * inNeuron.Model.Weights[i];
	}
	inNeuron.Model.Bias -= inNeuron.Learning.RateWeights * inNeuron.Learning.Error;
	
	/*
	length = Math.sqrt(sum);
	inNeuron.Model.WeightsNormalized = [];
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.WeightsNormalized[i] = inNeuron.Model.Weights[i]/length;
	}
	*/
	inNeuron.Model.WeightsNormalized = inNeuron.Model.Weights;

	inNeuron.Learning.Epoch++;
	inNeuron.Learning.Error = 0;
};
Neuron.Utilities.Delta = function(inNeuron, inTrainingSet)
{
	var i, j;
	var length = 0;
	var localError = 0;
	var errors = [];
	
	/* First, run the entire training set one-by-one through the neuron and record each error value into "errors" */
	for(i=0; i<inTrainingSet.length; i++)
	{
		// run the training vector through the neuron
		//inNeuron.Model.Inputs = inTrainingSet[i].Pos;
		Neuron.Utilities.Observe(inNeuron, inTrainingSet[i].Pos);
		
		// collect the error
		errors[i] = inTrainingSet[i].Type[0] - inNeuron.Outputs.Sigmoid;
	}
	
	/* For each component in the neuron's weight vector... */
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		localError = 0;
		
		/* ...look back across the training vectors in the same component... */
		for(j=0; j<inTrainingSet.length; j++)
		{
			/*
				...and sum the total error.
				We can't just sum "errors" becuase each member of "errors" needs scaled by a unique number:
				the component of the training vector that matches the component of the weight we are currently operating on.
			*/
			localError += errors[j] * inTrainingSet[j].Pos[i];
		}
		
		/* This sum is the adjustment for this component of the weight vector */
		inNeuron.Model.Weights[i] += localError * inNeuron.Learning.RateWeights;
		
		// normalization
		length += inNeuron.Model.Weights[i] * inNeuron.Model.Weights[i];
	}
	
	/* Do the same for the bias */
	localError = 0;
	for(i=0; i<inTrainingSet.length; i++)
	{
		localError += inNeuron.Learning.RateBias * errors[i];
	}
	inNeuron.Model.Bias -= localError;
	
	
	// normalization
	length = Math.sqrt(length);
	inNeuron.Model.WeightsNormalized = [];
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.WeightsNormalized[i] = inNeuron.Model.Weights[i]/length;
	}
	inNeuron.Learning.Epoch++;
	
};
Neuron.Create = function()
{
	var obj = {};
	
	obj.Model = {};
	obj.Model.Inputs = [];
	obj.Model.Weights = [];
	obj.Model.WeightsNormalized = [];
	obj.Model.Bias = 0;

	obj.Learning = {};
	obj.Learning.Epoch = 0;
	obj.Learning.Error = 0;
	obj.Learning.RateWeights = 0;
	obj.Learning.RateBias = 0;
	
	obj.Outputs = {};
	obj.Outputs.Linear = 0;
	obj.Outputs.Step = 0;
	obj.Outputs.Sigmoid = 0;
	obj.Outputs.SigmoidDeriv = 0;
	
	return obj;
};
Neuron.Setup = {};
Neuron.Setup.Observation = function(inNeuron, inWeights, inBias)
{
	inNeuron.Model.Weights = inWeights;
	inNeuron.Model.Bias = inBias;
	
	var i = 0;
	var length = 0;
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		length += inNeuron.Model.Weights[i] * inNeuron.Model.Weights[i];
		inNeuron.Model.Inputs[i] = 0;
	}
	length = Math.sqrt(length);
	inNeuron.Model.WeightsNormalized = [];
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.WeightsNormalized[i] = inNeuron.Model.Weights[i]/length;
	}
};
Neuron.Setup.Learning = function(inNeuron, inRateWeights, inRateBias)
{
	inNeuron.Learning.RateWeights = inRateWeights;
	inNeuron.Learning.RateBias = inRateBias;
};
</script>
<!-- neuron vizualizer -->
<script>
var NeuronViz = {};
NeuronViz.Instances = [];
NeuronViz.JQ = {};
NeuronViz.JQ.Contianer = $("#Neurons");
NeuronViz.CSS = {};
NeuronViz.CSS.ClassContainer = "Container";
NeuronViz.CSS.ClassLine = "Line";
NeuronViz.CSS.ClassBias = "Bias";
NeuronViz.Create = function(inNeuron)
{
	var obj = {};
	obj.Neuron = inNeuron;
	
	obj.JQ = {};
	obj.JQ.Container = $("<div class=\""+NeuronViz.CSS.ClassContainer+"\"></div>");
	obj.JQ.Line = $("<div class=\""+NeuronViz.CSS.ClassLine+"\"></div>");
	obj.JQ.Bias = $("<div class=\""+NeuronViz.CSS.ClassBias+"\"></div>");
	
	obj.JQ.Container.append(obj.JQ.Bias);
	obj.JQ.Container.append(obj.JQ.Line);
	NeuronViz.JQ.Contianer.append(obj.JQ.Container);
	
	NeuronViz.Instances.push(obj);
	return obj;
};
NeuronViz.Update = function()
{
	var i;
	var current;
	var x, y;
	var rad, deg;
	for(i=0; i<NeuronViz.Instances.length; i++)
	{
		current = NeuronViz.Instances[i];
		
		x = current.Neuron.Model.WeightsNormalized[0] * current.Neuron.Model.Bias;
		y = current.Neuron.Model.WeightsNormalized[1] * current.Neuron.Model.Bias;

		rad = Math.atan2(current.Neuron.Model.Weights[1], current.Neuron.Model.Weights[0]);
		deg = rad*(180/3.14);		
		
		current.JQ.Line.css({left:current.Neuron.Model.Bias+"px"});
		
		if(current.Neuron.Model.Bias < 0)
		{
			current.JQ.Bias.css({width:-current.Neuron.Model.Bias+"px", left:current.Neuron.Model.Bias+"px"});
		}
		else
		{
			current.JQ.Bias.css({width:current.Neuron.Model.Bias+"px", left:"0px"});
		}
		
		current.JQ.Container.css({"-webkit-transform":"rotate("+deg+"deg)", "-webkit-transform-origin": "0px 0px"});
	};
};

</script>



<!-- network -->
<script>
var Network = {};
Network.Instances = [];
Network.Create = function(inInputs)
{
	var i;
	var obj = {};
	obj.Layers = [];
	obj.ErrorTally = [];
	
	obj.Layers[0] = [];
	for(i=0; i<inInputs; i++)
	{
		obj.Layers[0][i] = Neuron.Create();
		Neuron.Setup.Observation(obj.Layers[0][i], [], 0);
	}
	
	obj.OutputLayer = obj.Layers[0];
	obj.InputLayer = obj.Layers[0];	
	
	Network.Instances.push(obj);
	return obj;
};
Network.Utilities = {};
Network.Utilities.Observe = function(inNetwork, inInputs)
{
	var i, j, k;
	var previousOutputs ;
	
	for(i=0; i<inNetwork.Layers[0].length; i++)
	{
		inNetwork.Layers[0][i].Outputs.Sigmoid = inInputs[i];
	}
	
	for(i=1; i<inNetwork.Layers.length; i++)
	{
		// collect all the outputs in the previous layer
		previousOutputs = [];
		for(j=0; j<inNetwork.Layers[i-1].length; j++)
		{
			previousOutputs[j] = inNetwork.Layers[i-1][j].Outputs.Sigmoid;
		}
		
		// reference them into the inputs of each neuron in the current layer
		// then have that neuron produce an output
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			Neuron.Utilities.Observe(inNetwork.Layers[i][j], previousOutputs);
		}
	}
};
Network.Utilities.Tally = function(inNetwork, inType)
{
	for(i=0; i<inNetwork.OutputLayer.length; i++)
	{
		try
		{
			inNetwork.ErrorTally[i] += inType[i] - inNetwork.OutputLayer[i].Outputs.Sigmoid;
		}
		catch(e)
		{
			console.log(e);
		}
	}
};
Network.Utilities.Flush = function(inNetwork)
{
	var i;
	inNetwork.ErrorTally = [];
	for(i=0; i<inNetwork.OutputLayer.length; i++)
	{
		inNetwork.ErrorTally[i] = 0;
	}
}
Network.Utilities.Error = function(inNetwork)
{
	var i, j, k;
	var currentNeuron;
	var previousNeuron;
	
	for(i=0; i<inNetwork.OutputLayer.length; i++)
	{
		inNetwork.OutputLayer[i].Learning.Error = inNetwork.ErrorTally[i] * inNetwork.OutputLayer[i].Outputs.SigmoidDeriv;
	}

	for(i=inNetwork.Layers.length-1; i>=2; i--)
	{
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			currentNeuron = inNetwork.Layers[i][j];
			for(k=0; k<currentNeuron.Model.Inputs.length; k++)
			{
				previousNeuron = inNetwork.Layers[i-1][k];
				previousNeuron.Learning.Error += currentNeuron.Model.WeightsNormalized[k] * currentNeuron.Learning.Error * previousNeuron.Outputs.SigmoidDeriv;
			}
		}
	}
};
Network.Utilities.Adjust = function(inNetwork)
{
	var i, j, k;
	var neuron;
	var delta;
	var length;
	
	for(i=1; i<inNetwork.Layers.length; i++)
	{
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			Neuron.Utilities.Learn(inNetwork.Layers[i][j]);
		}
	}
};
Network.Setup = {};
Network.Setup.AddLayer = function(inNetwork, inCount, inRateWeights, inRateBias)
{
	var i, j;
	var neuron;
	var leadingLayer = [];
	var newLayer = [];
	var initialWeights = [];
	
	leadingLayer = inNetwork.Layers[inNetwork.Layers.length-1];
	
	for(i=0; i<inCount; i++)
	{
		initialWeights = [];
		for(j=0; j<leadingLayer.length; j++)
		{
			initialWeights[j] = Math.random()-0.5;
		}
	
		neuron = Neuron.Create();
		Neuron.Setup.Observation(neuron, initialWeights, Math.random());
		Neuron.Setup.Learning(neuron, inRateWeights, inRateBias);
		
		newLayer[i] = neuron;
	};

	inNetwork.OutputLayer = newLayer;
	inNetwork.Layers.push(newLayer);
};
</script>
<!-- network vizualizer -->
<script>
var NetworkViz = {};
NetworkViz.Instances = [];
NetworkViz.JQ = {};
NetworkViz.JQ.Contianer = $("#Networks");
NetworkViz.Rasterization = {};
NetworkViz.Rasterization.Width = 600;
NetworkViz.Rasterization.Height = 600;
NetworkViz.Rasterization.Density = 0.2;
NetworkViz.Rasterization.Iterate = function(inIterator)
{
	var pixelWidth = NetworkViz.Rasterization.Width*NetworkViz.Rasterization.Density;
	var pixelHeight = NetworkViz.Rasterization.Height*NetworkViz.Rasterization.Density;
	var bitmapX, bitmapY;
	var screenX, screenY;
	for(bitmapX=0; bitmapX<pixelWidth; bitmapX++)
	{ 
		for(bitmapY=0; bitmapY<pixelHeight; bitmapY++)
		{
			screenX = (bitmapX-pixelWidth/2)/NetworkViz.Rasterization.Density;
			screenY = (bitmapY-pixelHeight/2)/NetworkViz.Rasterization.Density;
			inIterator(bitmapX, bitmapY, screenX, screenY);
		}
	}
};
NetworkViz.Rasterization.SetColor = function(inContext, inR, inG, inB, inX, inY)
{
	inR = Math.floor(inR*255);
	inG = Math.floor(inG*255);
	inB = Math.floor(inB*255);
	inContext.fillStyle = "rgba("+inR+","+inG+","+inB+",255)";
	inContext.fillRect( inX, inY, 1, 1 );
};
NetworkViz.Create = function(inNetwork)
{
	var obj = {};
	
	obj.Network = inNetwork;
	
	obj.JQ = {};
	obj.JQ.Canvas = $("<canvas></canvas>");
	obj.JQ.Canvas.attr({width:NetworkViz.Rasterization.Width*NetworkViz.Rasterization.Density, height:NetworkViz.Rasterization.Height*NetworkViz.Rasterization.Density});
	obj.JQ.Canvas.css({position:"absolute", left:-NetworkViz.Rasterization.Width/2+"px", top:-NetworkViz.Rasterization.Height/2+"px", width:NetworkViz.Rasterization.Width+"px", height:NetworkViz.Rasterization.Height+"px"});
	
	obj.Context = obj.JQ.Canvas.get(0).getContext("2d");
	
	obj.Iterator = function(inBitampX, inBitmapY, inScreenX, inScreenY)
	{
		Network.Utilities.Observe(obj.Network, [inScreenX, inScreenY]);
		NetworkViz.Rasterization.SetColor(obj.Context, obj.Network.OutputLayer[0].Outputs.Linear, obj.Network.OutputLayer[1].Outputs.Linear, obj.Network.OutputLayer[2].Outputs.Linear, inBitampX, inBitmapY);
	};
	
	NetworkViz.JQ.Contianer.append(obj.JQ.Canvas);
	NetworkViz.Instances.push(obj);
	
	return obj;
};
NetworkViz.Update = function()
{
	var i;
	for(i=0; i<NetworkViz.Instances.length; i++)
	{
		NetworkViz.Rasterization.Iterate(NetworkViz.Instances[i].Iterator);
	}
};
</script>



<!-- setup -->
<script>
	/*
		buncha crap for setting up training vectors
	*/
	var TypeA = {};
	TypeA.CSS = "TypeA";
	TypeA.Vector = [1, 0, 0];
	
	var TypeB = {};
	TypeB.CSS = "TypeB";
	TypeB.Vector = [0, 1, 0];
	
	var TypeC = {};
	TypeC.CSS = "TypeC";
	TypeC.Vector = [0, 0, 1];
	
	function tv(inCoords, inType)
	{
		var t = TrainingVector.Create(inCoords, inType.Vector);
		TrainingVectorViz.Create(t, inType.CSS);
	}
	
	tv([-100, 50], TypeA);
	tv([-50, 80], TypeA);
	tv([-10, 70], TypeA);
	tv([20, 80], TypeA);
	tv([-100, -50], TypeA);
	tv([-50, -60], TypeA);
	tv([-10, -70], TypeA);
	tv([20, -80], TypeA);
	tv([150, 80], TypeA);
	
	tv([-180, 0], TypeB);
	tv([-120, 10], TypeB);
	tv([-50, -10], TypeB);
	tv([20, -20], TypeB);
	tv([50, 6], TypeB);
	tv([50, 100], TypeB);
	tv([20, 108], TypeB);
	tv([-5, 110], TypeB);
	tv([-20, -130], TypeB);
	tv([-30, -120], TypeB);
	
	tv([-200, -200], TypeC);
	tv([-210, -190], TypeC);
	tv([-208, -120], TypeC);
	tv([-150, 120], TypeC);
	tv([-130, 130], TypeC);
	
	
	/*
		Build the network.
		Note that layer 1's weights are spread out in that for loop
	*/
	var net1 = Network.Create(2);
	Network.Setup.AddLayer(net1, 280, 0.05, 0);
	//Network.Setup.AddLayer(net1, 80, 0.05, 0);
	Network.Setup.AddLayer(net1, 3, 0.05, 0);
	NetworkViz.Create(net1);
	for(var i=0; i<net1.Layers[1].length; i++)
	{
		net1.Layers[1][i].Model.Bias *= 200;
	}
	
	
	/*
		Update animation stuff
	*/
	var Time = {};
	Time.Running = true;
	Time.Interval = 40;
	Time.RoutineInner = function()
	{
		for(var i = 0; i<TrainingVector.Instances.length; i++)
		{
			Network.Utilities.Flush(net1);
			Network.Utilities.Observe(net1, TrainingVector.Instances[i].Pos);
			Network.Utilities.Tally(net1, TrainingVector.Instances[i].Type);
			Network.Utilities.Error(net1);
			Network.Utilities.Adjust(net1);
		}
		NetworkViz.Update();
	};
	Time.RoutineOuter = function()
	{
		Time.RoutineInner();
		if(Time.Running)
			setTimeout(Time.RoutineOuter, Time.Interval);	
	};
	Time.Start = function()
	{
		Time.Running = true;
		Time.RoutineOuter();
	};
	Time.Stop = function()
	{
		Time.Running = false;
	};
	Time.Start();
	
	
</script>



</html>