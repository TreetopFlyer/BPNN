<!DOCTYPE html>
<html>
	<head>
		<script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
		<style>

			body, html
			{
				position:absolute;
				top:0px;
				left:0px;
				width:100%;
				height:100%;
				
				margin:0px;
				padding:0px;
				border:0px;
				
				background:#777;
				overflow:hidden;
			}
			
			#GridH
			{
				position:absolute;
				top:50%;
				left:0%;
				width:100%;
				height:100px;
				
				border-top:1px dashed #ccc;
			}
			#GridV
			{
				position:absolute;
				top:0%;
				left:50%;
				width:100px;
				height:100%;
				
				border-left:1px dashed #ccc;
			}
			
			#Neurons, #TrainingVectors, #Canvas
			{
				position:absolute;
				top:50%;
				left:50%;
			}
			
			#Neurons
			{
				display:none;
			}
			
			#Neurons .Container
			{
				position:absolute;
				left:0px;
				top:0px;
				width:0px;
				height:0px;
			}
			#Neurons .Container .Bias
			{
				position:absolute;
				top:-2px;
				left:0px;
				border-top:3px dotted #ccc;
			}
			#Neurons .Container .Line
			{
				position:absolute;
				top:-500px;
				left:0px;
				width:0px;
				height:1000px;
				border-left:2px solid #fff;
				border-right:2px solid #000;
			}
			
			#TrainingVectors .Container
			{
				display:block;
				position:absolute;
				width:0px;
				height:0px;
			}
			#TrainingVectors .Container .Offset
			{
				position:absolute;
				top:-7px;
				left:-7px;
				width:14px;
				height:14px;
				
				background:#F00;
				cursor:pointer;
				border-radius:5px;
				box-shadow:1px 1px 5px #333;
			}
			#TrainingVectors .TypeA .Offset
			{
				background:#fff;
			}
			#TrainingVectors .TypeB .Offset
			{
				background:#000;
			}
			
		</style>
	</head>
	<body>
	
		<div id="Canvas">
			<canvas></canvas>
		</div>
		<div id="GridH"></div>
		<div id="GridV"></div>
		<div id="Neurons"></div>
		<div id="TrainingVectors"></div>
		<div id="Networks"></div>
		
	
	
	</body>

<!-- training vector -->
<script>
var TrainingVector = {};
TrainingVector.Instances = [];
TrainingVector.Create = function(inPos, inType)
{
	var obj = {};

	obj.Pos = inPos;
	obj.Type = inType;
	obj.Error = 0;
	
	TrainingVector.Instances.push(obj);
	return obj;
};
</script>
<!-- training vector vizualizer -->
<script>
var TrainingVectorViz = {};
TrainingVectorViz.JQ = {};
TrainingVectorViz.JQ.Container = $("#TrainingVectors");
TrainingVectorViz.JQ.Document = $(document); 
TrainingVectorViz.CSS = {};
TrainingVectorViz.CSS.ClassContainer = "Container";
TrainingVectorViz.CSS.ClassOffset = "Offset";
TrainingVectorViz.Instances = [];

TrainingVectorViz.Create = function(inTrainingVector, inCSSClass)
{
	var obj = {};
	
	obj.TrainingVector = inTrainingVector;
	
	obj.JQ = {};
	obj.JQ.Container = $("<div class=\""+TrainingVectorViz.CSS.ClassContainer+" "+inCSSClass+"\"></div>");
	obj.JQ.Offset = $("<div class=\""+TrainingVectorViz.CSS.ClassOffset+"\"></div>");
	
	obj.Mouse = {};
	obj.Mouse.OldX = 0;
	obj.Mouse.NewX = 0;
	obj.Mouse.OldY = 0;
	obj.Mouse.NewY = 0;
	
	obj.Handlers = {};
	obj.Handlers.MouseDown = function(e)
	{
		obj.Mouse.NewX = e.pageX;
		obj.Mouse.NewY = e.pageY;		
	
		obj.JQ.Container.unbind("mousedown", obj.Handlers.MouseDown);
		TrainingVectorViz.JQ.Document.bind("mousemove", obj.Handlers.MouseMove);
		TrainingVectorViz.JQ.Document.bind("mouseup", obj.Handlers.MouseUp);
	};
	obj.Handlers.MouseMove = function(e)
	{
		obj.Mouse.OldX = obj.Mouse.NewX;
		obj.Mouse.OldY = obj.Mouse.NewY;
		
		obj.Mouse.NewX = e.pageX;
		obj.Mouse.NewY = e.pageY;
		
		obj.TrainingVector.Pos[0] += obj.Mouse.NewX - obj.Mouse.OldX;
		obj.TrainingVector.Pos[1] += obj.Mouse.NewY - obj.Mouse.OldY;
		TrainingVectorViz.Update(obj);
	};
	obj.Handlers.MouseUp = function(e)
	{
		TrainingVectorViz.JQ.Document.unbind("mousemove", obj.Handlers.MouseMove);
		TrainingVectorViz.JQ.Document.unbind("mouseup", obj.Handlers.MouseUp);
		obj.JQ.Container.bind("mousedown", obj.Handlers.MouseDown);
	};
	obj.Handlers.MouseUp();
	
	obj.JQ.Container.append(obj.JQ.Offset);
	TrainingVectorViz.JQ.Container.append(obj.JQ.Container);
	TrainingVectorViz.Instances.push(obj);
	TrainingVectorViz.Update(obj);
	return obj;
};
TrainingVectorViz.Update = function(inTrainingVectorViz)
{
	inTrainingVectorViz.JQ.Container.css({left:(inTrainingVectorViz.TrainingVector.Pos[0])+"px", top:(inTrainingVectorViz.TrainingVector.Pos[1])+"px"});
};
</script>

<!-- neuron -->
<script>
var Neuron = {};
Neuron.Utilities = {};
Neuron.Utilities.Observe = function(inNeuron, inInputs)
{
	var i = 0;
	var sum = 0;
	inNeuron.Model.Inputs = inInputs;
	for(i=0; i<inNeuron.Model.WeightsNormalized.length; i++)
	{
		sum += inNeuron.Model.WeightsNormalized[i] * inNeuron.Model.Inputs[i];
	}
	inNeuron.Outputs.Linear = sum - inNeuron.Model.Bias;
	
	inNeuron.Outputs.Sigmoid = 	1 / (1+Math.pow(Math.E, -inNeuron.Outputs.Linear));
	inNeuron.Outputs.SigmoidDeriv = inNeuron.Outputs.Sigmoid * (1 - inNeuron.Outputs.Sigmoid);
	
	if(inNeuron.Outputs.Linear < 0)
		inNeuron.Outputs.Step = 0;
	else
		inNeuron.Outputs.Step = 1;
};
Neuron.Utilities.Normalize = function(inNeuron)
{
	var i;
	var length;
	
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		length += inNeuron.Model.Weights[i] * inNeuron.Model.Weights[i];
	}
	length = Math.sqrt(length);
	for(i=0; i<inNeuron.Model.WeightsNormalized.length; i++)
	{
		inNeuron.Model.WeightsNormalized[i] = inNeuron.Model.Weights[i]/length;
	}
};
Neuron.Utilities.Learn = function(inNeuron)
{
	var i =0;
	var sum = 0;
	var length = 0;

	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.Weights[i] += inNeuron.Learning.RateWeights * inNeuron.Learning.Error * inNeuron.Model.Inputs[i];
		sum += inNeuron.Model.Weights[i] * inNeuron.Model.Weights[i];
	}
	inNeuron.Model.Bias -= inNeuron.Learning.RateBias * inNeuron.Learning.Error;
	length = Math.sqrt(sum);
	inNeuron.Model.WeightsNormalized = [];
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.WeightsNormalized[i] = inNeuron.Model.Weights[i]/length;
	}

	inNeuron.Learning.Epoch++;
};
Neuron.Utilities.Delta = function(inNeuron, inTrainingSet)
{
	var i, j;
	var length = 0;
	var localError = 0;
	var errors = [];
	
	/* First, run the entire training set one-by-one through the neuron and record each error value into "errors" */
	for(i=0; i<inTrainingSet.length; i++)
	{
		// run the training vector through the neuron
		//inNeuron.Model.Inputs = inTrainingSet[i].Pos;
		Neuron.Utilities.Observe(inNeuron, inTrainingSet[i].Pos);
		
		// collect the error
		errors[i] = inTrainingSet[i].Type[0] - inNeuron.Outputs.Sigmoid;
	}
	
	/* For each component in the neuron's weight vector... */
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		localError = 0;
		
		/* ...look back across the training vectors in the same component... */
		for(j=0; j<inTrainingSet.length; j++)
		{
			/*
				...and sum the total error.
				We can't just sum "errors" becuase each member of "errors" needs scaled by a unique number:
				the component of the training vector that matches the component of the weight we are currently operating on.
			*/
			localError += errors[j] * inTrainingSet[j].Pos[i];
		}
		
		/* This sum is the adjustment for this component of the weight vector */
		inNeuron.Model.Weights[i] += localError * inNeuron.Learning.RateWeights;
		
		// normalization
		length += inNeuron.Model.Weights[i] * inNeuron.Model.Weights[i];
	}
	
	/* Do the same for the bias */
	localError = 0;
	for(i=0; i<inTrainingSet.length; i++)
	{
		localError += inNeuron.Learning.RateBias * errors[i];
	}
	inNeuron.Model.Bias -= localError;
	
	
	// normalization
	length = Math.sqrt(length);
	inNeuron.Model.WeightsNormalized = [];
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.WeightsNormalized[i] = inNeuron.Model.Weights[i]/length;
	}
	inNeuron.Learning.Epoch++;
	
};
Neuron.Create = function()
{
	var obj = {};
	
	obj.Model = {};
	obj.Model.Inputs = [];
	obj.Model.Weights = [];
	obj.Model.WeightsNormalized = [];
	obj.Model.Bias = 0;

	obj.Learning = {};
	obj.Learning.Epoch = 0;
	obj.Learning.Error = 0;
	obj.Learning.RateWeights = 0;
	obj.Learning.RateBias = 0;
	
	obj.Outputs = {};
	obj.Outputs.Linear = 0;
	obj.Outputs.Step = 0;
	obj.Outputs.Sigmoid = 0;
	obj.Outputs.SigmoidDeriv = 0;
	
	return obj;
};
Neuron.Setup = {};
Neuron.Setup.Observation = function(inNeuron, inWeights, inBias)
{
	inNeuron.Model.Weights = inWeights;
	inNeuron.Model.Bias = inBias;
	
	var i = 0;
	var length = 0;
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		length += inNeuron.Model.Weights[i] * inNeuron.Model.Weights[i];
		inNeuron.Model.Inputs[i] = 0;
	}
	length = Math.sqrt(length);
	inNeuron.Model.WeightsNormalized = [];
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.WeightsNormalized[i] = inNeuron.Model.Weights[i]/length;
	}
};
Neuron.Setup.Learning = function(inNeuron, inRateWeights, inRateBias)
{
	inNeuron.Learning.RateWeights = inRateWeights;
	inNeuron.Learning.RateBias = inRateBias;
};
</script>
<!-- neuron vizualizer -->
<script>
var NeuronViz = {};
NeuronViz.Instances = [];
NeuronViz.JQ = {};
NeuronViz.JQ.Contianer = $("#Neurons");
NeuronViz.CSS = {};
NeuronViz.CSS.ClassContainer = "Container";
NeuronViz.CSS.ClassLine = "Line";
NeuronViz.CSS.ClassBias = "Bias";
NeuronViz.Create = function(inNeuron)
{
	var obj = {};
	obj.Neuron = inNeuron;
	
	obj.JQ = {};
	obj.JQ.Container = $("<div class=\""+NeuronViz.CSS.ClassContainer+"\"></div>");
	obj.JQ.Line = $("<div class=\""+NeuronViz.CSS.ClassLine+"\"></div>");
	obj.JQ.Bias = $("<div class=\""+NeuronViz.CSS.ClassBias+"\"></div>");
	
	obj.JQ.Container.append(obj.JQ.Bias);
	obj.JQ.Container.append(obj.JQ.Line);
	NeuronViz.JQ.Contianer.append(obj.JQ.Container);
	
	NeuronViz.Instances.push(obj);
	return obj;
};
NeuronViz.Update = function()
{
	var i;
	var current;
	var x, y;
	var rad, deg;
	for(i=0; i<NeuronViz.Instances.length; i++)
	{
		current = NeuronViz.Instances[i];
		
		x = current.Neuron.Model.WeightsNormalized[0] * current.Neuron.Model.Bias;
		y = current.Neuron.Model.WeightsNormalized[1] * current.Neuron.Model.Bias;

		rad = Math.atan2(current.Neuron.Model.Weights[1], current.Neuron.Model.Weights[0]);
		deg = rad*(180/3.14);		
		
		current.JQ.Line.css({left:current.Neuron.Model.Bias+"px"});
		
		if(current.Neuron.Model.Bias < 0)
		{
			current.JQ.Bias.css({width:-current.Neuron.Model.Bias+"px", left:current.Neuron.Model.Bias+"px"});
		}
		else
		{
			current.JQ.Bias.css({width:current.Neuron.Model.Bias+"px", left:"0px"});
		}
		
		current.JQ.Container.css({"-webkit-transform":"rotate("+deg+"deg)", "-webkit-transform-origin": "0px 0px"});
	};
};

</script>

<!-- network -->
<script>
var Network = {};
Network.Instances = [];
Network.Create = function(inInputs)
{
	var i;
	var obj = {};
	obj.Layers = [];
	
	obj.Layers[0] = [];
	for(i=0; i<inInputs; i++)
	{
		obj.Layers[0][i] = Neuron.Create();
		Neuron.Setup.Observation(obj.Layers[0][i], [], 0);
	}
	
	Network.Instances.push(obj);
	return obj;
};
Network.Utilities = {};
Network.Utilities.Observe = function(inNetwork, inInputs)
{
	var i, j, k;
	var previousOutputs ;
	
	for(i=0; i<inNetwork.Layers[0].length; i++)
	{
		inNetwork.Layers[0][i].Outputs.Sigmoid = inInputs[i];
	}
	
	for(i=1; i<inNetwork.Layers.length; i++)
	{
		// collect all the outputs in the previous layer
		previousOutputs = [];
		for(j=0; j<inNetwork.Layers[i-1].length; j++)
		{
			previousOutputs[j] = inNetwork.Layers[i-1][j].Outputs.Sigmoid;
		}
		
		// reference them into the inputs of each neuron in the current layer
		// then have that neuron produce an output
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			//inNetwork.Layers[i][j].Inputs = previousOutputs;
			Neuron.Utilities.Observe(inNetwork.Layers[i][j], previousOutputs);
			inNetwork.Layers[i][j].Learning.Error = 0;
		}
	}
};
Network.Utilities.Error = function(inNetwork, inType)
{
	var i, j, k;
	var currentNeuron;
	var previousNeuron;
	var leading = inNetwork.Layers[inNetwork.Layers.length -1];
	for(i=0; i<leading.length; i++)
	{
		leading[i].Learning.Error = inType[i] - leading[i].Outputs.Sigmoid;
	}
	
	for(i=inNetwork.Layers.length-1; i>=2; i--)
	{
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			currentNeuron = inNetwork.Layers[i][j];
			for(k=0; k<currentNeuron.Model.Inputs.length; k++)
			{
				previousNeuron = inNetwork.Layers[i-1][k];
				previousNeuron.Learning.Error += currentNeuron.Model.WeightsNormalized[k] * currentNeuron.Learning.Error;
			}
		}
	}
};
Network.Utilities.Adjust = function(inNetwork)
{
	var i, j, k;
	var neuron;
	var delta;
	var length;
	
	for(i=1; i<inNetwork.Layers.length; i++)
	{
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			length = 0;
			neuron = inNetwork.Layers[i][j];	
			
			for(k=0; k<neuron.Model.Weights.length; k++)
			{
				delta = neuron.Learning.RateWeights * neuron.Learning.Error * neuron.Outputs.SigmoidDeriv * neuron.Model.Inputs[k];
				neuron.Model.Weights[k] += delta;
				length += neuron.Model.Weights[k] * neuron.Model.Weights[k];
			}

			length = Math.sqrt(length);
		
			for(k=0; k<neuron.Model.WeightsNormalized.length; k++)
			{
				neuron.Model.WeightsNormalized[k] = neuron.Model.Weights[k] / length;
			}

			
			neuron.Model.Bias -= neuron.Learning.RateBias * neuron.Learning.Error * neuron.Outputs.SigmoidDeriv;
			

		}
	}
};

Network.Setup = {};
Network.Setup.AddLayer = function(inNetwork, inCount, inRateWeights, inRateBias)
{
	var i, j;
	var neuron;
	var leadingLayer = [];
	var newLayer = [];
	var initialWeights = [];
	
	leadingLayer = inNetwork.Layers[inNetwork.Layers.length-1];
	
	for(i=0; i<inCount; i++)
	{
		initialWeights = [];
		for(j=0; j<leadingLayer.length; j++)
		{
			initialWeights[j] = Math.random()-0.5;
		}
	
		neuron = Neuron.Create();
		Neuron.Setup.Observation(neuron, initialWeights, Math.random());
		Neuron.Setup.Learning(neuron, inRateWeights, inRateBias);
		NeuronViz.Create(neuron);
		
		newLayer[i] = neuron;
	};
	
	inNetwork.Layers.push(newLayer);
};
</script>
<!-- network vizualizer -->
<script>
var NetworkViz = {};
NetworkViz.Instances = [];
NetworkViz.JQ = {};
NetworkViz.JQ.Container = $("#Networks");
NetworkViz.CSS = {};
NetworkViz.CSS.ClassContainer = "Container";
NetworkViz.CSS.ClassLayer = "Layer";
NetworkViz.CSS.ClassNeuron = "Neuron";
NetworkViz.Create = function(inNetwork)
{
	var i, j, k;
	var obj = {};
	
	obj.Network = inNetwork;
	
	obj.JQ = {};
	obj.JQ.Container = $("<div class=\""+NetworkViz.CSS.ClassContainer+"\"></div>");
	obj.JQ.Layers = $();
	
	var layer, neuron, error, weights, output;
	for(i=0; i<inNetwork.Layers.length; i++)
	{
		layer = $("<div class=\""+NetworkViz.CSS.ClassLayer+"\"></div>");
		obj.JQ.Layers = obj.JQ.Layers.add(layer);
		obj.JQ.Container.append(layer);
		
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			neuron = $("<div class=\""+NetworkViz.CSS.ClassNeuron+"\"></div>");
			error = $("<div class=\"\"></div>");
			layer.append(neuron);
		}
	}
	
	NetworkViz.Instances.push(obj);
	return obj;
};
</script>

<!-- setup -->
<script>

	var t1 = TrainingVector.Create([-100, 50], [0]);
	TrainingVectorViz.Create(t1, "TypeA");

	var t2 = TrainingVector.Create([-50, 80], [0]);
	TrainingVectorViz.Create(t2, "TypeA");
	
	var t3 = TrainingVector.Create([-10, 70], [0]);
	TrainingVectorViz.Create(t3, "TypeA");

	var t4 = TrainingVector.Create([20, 80], [0]);
	TrainingVectorViz.Create(t4, "TypeA");
	
	
	var t5 = TrainingVector.Create([-100, -50], [0]);
	TrainingVectorViz.Create(t5, "TypeA");

	var t6 = TrainingVector.Create([-50, -60], [0]);
	TrainingVectorViz.Create(t6, "TypeA");
	
	var t7 = TrainingVector.Create([-10, -70], [0]);
	TrainingVectorViz.Create(t7, "TypeA");

	var t8 = TrainingVector.Create([20, -80], [0]);
	TrainingVectorViz.Create(t8, "TypeA");
	
	
	
	var t9 = TrainingVector.Create([-180, 0], [1]);
	TrainingVectorViz.Create(t9, "TypeB");

	var t10 = TrainingVector.Create([-120, 0], [1]);
	TrainingVectorViz.Create(t10, "TypeB");
	
	var t11 = TrainingVector.Create([-50, 0], [1]);
	TrainingVectorViz.Create(t11, "TypeB");
	
	var t12 = TrainingVector.Create([20, 0], [1]);
	TrainingVectorViz.Create(t12, "TypeB");
	
	var t12 = TrainingVector.Create([50, 0], [1]);
	TrainingVectorViz.Create(t12, "TypeB");
	
	var net1 = Network.Create(2);
	Network.Setup.AddLayer(net1, 200, 0.2, 1);
	Network.Setup.AddLayer(net1, 1, 0.5, 0.5);
	
	var i;
	for(i=0; i<net1.Layers[1].length; i++)
	{
		net1.Layers[1][i].Model.Bias *= 400;
	}

	
	var index = 0;
	var set = TrainingVector.Instances;
	
	var Canvas = {};
	Canvas.JQ = $("#Canvas canvas")
	Canvas.Context = Canvas.JQ.get(0).getContext("2d");
	Canvas.Width = 500;
	Canvas.Height = 400;
	Canvas.Density = 0.1;
	
	Canvas.JQ.attr({width:Canvas.Width*Canvas.Density, height:Canvas.Height*Canvas.Density});
	Canvas.JQ.css({position:"absolute", left:-Canvas.Width/2+"px", top:-Canvas.Height/2+"px", width:Canvas.Width+"px", height:Canvas.Height+"px"});
	
	
	Canvas.Iterate = function(inHandler)
	{
		var pixelWidth = Canvas.Width*Canvas.Density;
		var pixelHeight = Canvas.Height*Canvas.Density;
		var x, y;
		var worldX, worldY;
		for(x=0; x<pixelWidth; x++)
		{
			for(y=0; y<pixelHeight; y++)
			{
				worldX = (x-pixelWidth/2)/Canvas.Density;
				worldY = (y-pixelHeight/2)/Canvas.Density;
				inHandler(x, y, worldX, worldY);
			}
		}
	};
	Canvas.Value = function(inValue, inX, inY)
	{
		inValue = Math.floor(inValue*255);
		Canvas.Context.fillStyle = "rgba("+inValue+","+inValue+","+inValue+",255)";
		Canvas.Context.fillRect( inX, inY, 1, 1 );
	};

	var timer = setInterval(function()
	{
		
		Network.Utilities.Observe(net1, set[index].Pos);
		Network.Utilities.Error(net1, set[index].Type);
		Network.Utilities.Adjust(net1);
		NeuronViz.Update();
		
		Canvas.Iterate(function(inCanvasX, inCanvasY, inWorldX, inWorldY){
			Network.Utilities.Observe(net1, [inWorldX, inWorldY]);
			var output = net1.Layers[net1.Layers.length-1][0].Outputs.Sigmoid;
			Canvas.Value(output, inCanvasX, inCanvasY);
		});
		

		index++;
		if(index >= set.length)
			index = 0;

		
	}, 20);
;
		
	
	
</script>


</html>