<!DOCTYPE html>
<html>
	<head>
		<title>BPNN</title>
		<script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
		<style>

			body, html
			{
				position:absolute;
				top:0px;
				left:0px;
				width:100%;
				height:100%;
				
				margin:0px;
				padding:0px;
				border:0px;
				
				background:#777;
				overflow:hidden;
			}
			
			#GridH
			{
				position:absolute;
				top:50%;
				left:0%;
				width:100%;
				height:100px;
				
				border-top:1px dashed #ccc;
			}
			#GridV
			{
				position:absolute;
				top:0%;
				left:50%;
				width:100px;
				height:100%;
				
				border-left:1px dashed #ccc;
			}
			
			#Neurons, #TrainingVectors, #Networks
			{
				position:absolute;
				top:50%;
				left:50%;
			}
			
			#Neurons
			{
				display:none;
			}
			
			#Neurons .Container
			{
				position:absolute;
				left:0px;
				top:0px;
				width:0px;
				height:0px;
			}
			#Neurons .Container .Bias
			{
				position:absolute;
				top:-2px;
				left:0px;
				border-top:3px dotted #ccc;
			}
			#Neurons .Container .Line
			{
				position:absolute;
				top:-500px;
				left:0px;
				width:0px;
				height:1000px;
				border-left:2px solid #fff;
				border-right:2px solid #000;
			}
			
			#TrainingVectors .Container
			{
				display:block;
				position:absolute;
				width:0px;
				height:0px;
			}
			#TrainingVectors .Container .Offset
			{
				position:absolute;
				top:-4px;
				left:-4px;
				width:8px;
				height:8px;
				
				background:#F00;
				cursor:pointer;
				border-radius:5px;
				border:1px solid #000;
				box-shadow:0px 0px 10px #fff;
			}
			#TrainingVectors .TypeA .Offset
			{
				background:#F00;
			}
			#TrainingVectors .TypeB .Offset
			{
				background:#0F0;
			}
			#TrainingVectors .TypeC .Offset
			{
				background:#00F;
			}
			
		</style>
	</head>
	<body>
		<div id="Networks"></div>
		<div id="Neurons"></div>
		<div id="GridH"></div>
		<div id="GridV"></div>
		<div id="TrainingVectors"></div>
	</body>


<!-- training vector -->
<script>
var TrainingVector = {};
TrainingVector.Instances = [];
TrainingVector.Create = function(inPos, inType)
{
	var obj = {};

	obj.Pos = inPos;
	obj.Type = inType;
	obj.Error = 0;
	
	TrainingVector.Instances.push(obj);
	return obj;
};
</script>
<!-- training vector vizualizer -->
<script>
var TrainingVectorViz = {};
TrainingVectorViz.JQ = {};
TrainingVectorViz.JQ.Container = $("#TrainingVectors");
TrainingVectorViz.JQ.Document = $(document); 
TrainingVectorViz.CSS = {};
TrainingVectorViz.CSS.ClassContainer = "Container";
TrainingVectorViz.CSS.ClassOffset = "Offset";
TrainingVectorViz.Instances = [];

TrainingVectorViz.Create = function(inTrainingVector, inCSSClass)
{
	var obj = {};
	
	obj.TrainingVector = inTrainingVector;
	
	obj.JQ = {};
	obj.JQ.Container = $("<div class=\""+TrainingVectorViz.CSS.ClassContainer+" "+inCSSClass+"\"></div>");
	obj.JQ.Offset = $("<div class=\""+TrainingVectorViz.CSS.ClassOffset+"\"></div>");
	
	obj.Mouse = {};
	obj.Mouse.OldX = 0;
	obj.Mouse.NewX = 0;
	obj.Mouse.OldY = 0;
	obj.Mouse.NewY = 0;
	
	obj.Handlers = {};
	obj.Handlers.MouseDown = function(e)
	{
		obj.Mouse.NewX = e.pageX;
		obj.Mouse.NewY = e.pageY;		
	
		obj.JQ.Container.unbind("mousedown", obj.Handlers.MouseDown);
		TrainingVectorViz.JQ.Document.bind("mousemove", obj.Handlers.MouseMove);
		TrainingVectorViz.JQ.Document.bind("mouseup", obj.Handlers.MouseUp);
	};
	obj.Handlers.MouseMove = function(e)
	{
		obj.Mouse.OldX = obj.Mouse.NewX;
		obj.Mouse.OldY = obj.Mouse.NewY;
		
		obj.Mouse.NewX = e.pageX;
		obj.Mouse.NewY = e.pageY;
		
		obj.TrainingVector.Pos[0] += obj.Mouse.NewX - obj.Mouse.OldX;
		obj.TrainingVector.Pos[1] += obj.Mouse.NewY - obj.Mouse.OldY;
		TrainingVectorViz.Update(obj);
	};
	obj.Handlers.MouseUp = function(e)
	{
		TrainingVectorViz.JQ.Document.unbind("mousemove", obj.Handlers.MouseMove);
		TrainingVectorViz.JQ.Document.unbind("mouseup", obj.Handlers.MouseUp);
		obj.JQ.Container.bind("mousedown", obj.Handlers.MouseDown);
	};
	obj.Handlers.MouseUp();
	
	obj.JQ.Container.append(obj.JQ.Offset);
	TrainingVectorViz.JQ.Container.append(obj.JQ.Container);
	TrainingVectorViz.Instances.push(obj);
	TrainingVectorViz.Update(obj);
	return obj;
};
TrainingVectorViz.Update = function(inTrainingVectorViz)
{
	inTrainingVectorViz.JQ.Container.css({left:(inTrainingVectorViz.TrainingVector.Pos[0])+"px", top:(inTrainingVectorViz.TrainingVector.Pos[1])+"px"});
};
</script>


<!-- neuron -->
<script>
var Neuron = {};

/*
Run the input vector through the neuron.
It is assumed that the input (Neuron.Model.Inputs[]) has been set inside the neuron at this point.
The output is processed into multiple values:
1.) Step
2.) Linear
3.) Sigmoid
4.) Sigmoid Derivative
*/
Neuron.Observe = function(inNeuron)
{
	var i = 0;
	var sum = 0;
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		sum += inNeuron.Model.Weights[i] * inNeuron.Model.Inputs[i];
	}
	inNeuron.Outputs.Linear = sum - inNeuron.Model.Bias;
	inNeuron.Outputs.Sigmoid = 	1 / (1+Math.pow(1.8, -inNeuron.Outputs.Linear));
	inNeuron.Outputs.SigmoidDeriv = inNeuron.Outputs.Sigmoid * (1 - inNeuron.Outputs.Sigmoid);
	if(inNeuron.Outputs.Linear < 0)
		inNeuron.Outputs.Step = 0;
	else
		inNeuron.Outputs.Step = 1;
};

/*
	Adjust the weight vector (and bias) based on the amount of error recorded at this neuron.
	It is assumed that the error value (Neuron.Learning.Error) has already been set at this point.
	Note that after this process, the error value is reset to 0.
*/
Neuron.Learn = function(inNeuron)
{
	var i;
	var weightedError = inNeuron.Learning.Rate * inNeuron.Learning.Error;
	for(i=0; i<inNeuron.Model.Weights.length; i++)
	{
		inNeuron.Model.Weights[i] -= weightedError * inNeuron.Model.Inputs[i];
	}
	inNeuron.Model.Bias -= weightedError;
	inNeuron.Learning.Epoch++;
	inNeuron.Learning.Error = 0;
};

/*
	Build a new neuron with the specified weight vector and learning rate.
	The weight vector and bias are randomized to -1 < w < 1
*/
Neuron.Create = function(inInputs, inLearningRate)
{
	var i;
	var obj = {};
	
	obj.Model = {};
	obj.Model.Inputs = [];
	obj.Model.Weights = [];
	obj.Model.Bias = 0;

	obj.Learning = {};
	obj.Learning.Epoch = 0;
	obj.Learning.Error = 0;
	obj.Learning.Rate = inLearningRate;
	
	obj.Outputs = {};
	obj.Outputs.Linear = 0;
	obj.Outputs.Step = 0;
	obj.Outputs.Sigmoid = 0;
	obj.Outputs.SigmoidDeriv = 0;
	
	for(i=0; i<inInputs; i++)
	{
		obj.Model.Weights[i] = (Math.random() - 0.5);
		obj.Model.Inputs[i] = 0;
	}
	obj.Model.Bias = (Math.random() - 0.5);
	
	return obj;
};
</script>
<!-- neuron vizualizer -->
<script>
var NeuronViz = {};
NeuronViz.Instances = [];
NeuronViz.JQ = {};
NeuronViz.JQ.Contianer = $("#Neurons");
NeuronViz.CSS = {};
NeuronViz.CSS.ClassContainer = "Container";
NeuronViz.CSS.ClassLine = "Line";
NeuronViz.CSS.ClassBias = "Bias";
NeuronViz.Create = function(inNeuron)
{
	var obj = {};
	obj.Neuron = inNeuron;
	
	obj.JQ = {};
	obj.JQ.Container = $("<div class=\""+NeuronViz.CSS.ClassContainer+"\"></div>");
	obj.JQ.Line = $("<div class=\""+NeuronViz.CSS.ClassLine+"\"></div>");
	obj.JQ.Bias = $("<div class=\""+NeuronViz.CSS.ClassBias+"\"></div>");
	
	obj.JQ.Container.append(obj.JQ.Bias);
	obj.JQ.Container.append(obj.JQ.Line);
	NeuronViz.JQ.Contianer.append(obj.JQ.Container);
	
	NeuronViz.Instances.push(obj);
	return obj;
};
NeuronViz.Update = function()
{
	var i;
	var current;
	var x, y;
	var rad, deg;
	for(i=0; i<NeuronViz.Instances.length; i++)
	{
		current = NeuronViz.Instances[i];
		
		x = current.Neuron.Model.Weights[0] * current.Neuron.Model.Bias;
		y = current.Neuron.Model.Weights[1] * current.Neuron.Model.Bias;

		rad = Math.atan2(current.Neuron.Model.Weights[1], current.Neuron.Model.Weights[0]);
		deg = rad*(180/3.14);		
		
		current.JQ.Line.css({left:current.Neuron.Model.Bias+"px"});
		
		if(current.Neuron.Model.Bias < 0)
		{
			current.JQ.Bias.css({width:-current.Neuron.Model.Bias+"px", left:current.Neuron.Model.Bias+"px"});
		}
		else
		{
			current.JQ.Bias.css({width:current.Neuron.Model.Bias+"px", left:"0px"});
		}
		
		current.JQ.Container.css({"-webkit-transform":"rotate("+deg+"deg)", "-webkit-transform-origin": "0px 0px"});
	};
};

</script>


<!-- network -->
<script>
var Network = {};
Network.Instances = [];
Network.Create = function(inInputs)
{
	var i;
	var obj = {};
	obj.Layers = [];
	obj.ErrorTally = [];
	
	obj.Layers[0] = [];
	for(i=0; i<inInputs; i++)
	{
		obj.Layers[0][i] = Neuron.Create(0, 0);
	}
	
	obj.OutputLayer = obj.Layers[0];
	obj.InputLayer = obj.Layers[0];	
	
	Network.Instances.push(obj);
	return obj;
};
Network.Observe = function(inNetwork, inInput)
{
	var i, j, k;
	var previousOutputs ;
	
	for(i=0; i<inNetwork.Layers[0].length; i++)
	{
		inNetwork.Layers[0][i].Outputs.Sigmoid = inInput[i];
	}
	
	// starting at one up from the input layer and moving to the output layer
	for(i=1; i<inNetwork.Layers.length; i++)
	{
		// collect all the outputs in the previous layer
		previousOutputs = [];
		for(j=0; j<inNetwork.Layers[i-1].length; j++)
		{
			previousOutputs[j] = inNetwork.Layers[i-1][j].Outputs.Sigmoid;
		}
		
		// reference them into the inputs of each neuron in the current layer
		// then have that neuron produce an output
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			inNetwork.Layers[i][j].Model.Inputs = previousOutputs;
			Neuron.Observe(inNetwork.Layers[i][j]);
		}
	}
};
Network.Learn = function(inNetwork, inOutput)
{
	var i, j, k;
	var miss;
	var currentNeuron;
	var previousNeuron;
	
	// calculate the difference between what each output neuron says and what inOuptut[i] says
	for(i=0; i<inNetwork.OutputLayer.length; i++)
	{
		miss = inNetwork.OutputLayer[i].Outputs.Sigmoid - inOutput[i];
		inNetwork.OutputLayer[i].Learning.Error = miss * inNetwork.OutputLayer[i].Outputs.SigmoidDeriv;
	}

	// start at the ouput layer and work back
	for(i=inNetwork.Layers.length-1; i>=2; i--)
	{
		for(j=0; j<inNetwork.Layers[i].length; j++)
		{
			// for some neuron on the current layer...
			currentNeuron = inNetwork.Layers[i][j];
			
			// ...find the nodes at are feeding into it
			for(k=0; k<currentNeuron.Model.Inputs.length; k++)
			{
				// move the error at the current node back into each of its inputs, scaled by that input's weight
				previousNeuron = inNetwork.Layers[i-1][k];
				previousNeuron.Learning.Error += currentNeuron.Model.Weights[k] * currentNeuron.Learning.Error * previousNeuron.Outputs.SigmoidDeriv;
			}
			
			// now that current neuon's error has been calculated and sent back to its dependents, it can be adjusted
			Neuron.Learn(currentNeuron);
		}
	}
	
};
Network.AddLayer = function(inNetwork, inCount, inRate)
{
	var i, j;
	var newLayer = [];
	
	for(i=0; i<inCount; i++)
	{
		newLayer[i] = Neuron.Create(inNetwork.OutputLayer.length, inRate);
	};

	inNetwork.OutputLayer = newLayer;
	inNetwork.Layers.push(newLayer);
};
</script>
<!-- network vizualizer -->
<script>
var NetworkViz = {};
NetworkViz.Instances = [];
NetworkViz.JQ = {};
NetworkViz.JQ.Contianer = $("#Networks");
NetworkViz.Rasterization = {};
NetworkViz.Rasterization.Width = 600;
NetworkViz.Rasterization.Height = 600;
NetworkViz.Rasterization.Density = 0.2;
NetworkViz.Rasterization.Iterate = function(inIterator)
{
	var pixelWidth = NetworkViz.Rasterization.Width*NetworkViz.Rasterization.Density;
	var pixelHeight = NetworkViz.Rasterization.Height*NetworkViz.Rasterization.Density;
	var bitmapX, bitmapY;
	var screenX, screenY;
	for(bitmapX=0; bitmapX<pixelWidth; bitmapX++)
	{ 
		for(bitmapY=0; bitmapY<pixelHeight; bitmapY++)
		{
			screenX = (bitmapX-pixelWidth/2)/NetworkViz.Rasterization.Density;
			screenY = (bitmapY-pixelHeight/2)/NetworkViz.Rasterization.Density;
			inIterator(bitmapX, bitmapY, screenX, screenY);
		}
	}
};
NetworkViz.Rasterization.SetColor = function(inContext, inR, inG, inB, inX, inY)
{
	inR = Math.floor(inR*255);
	inG = Math.floor(inG*255);
	inB = Math.floor(inB*255);
	inContext.fillStyle = "rgba("+inR+","+inG+","+inB+",255)";
	inContext.fillRect( inX, inY, 1, 1 );
};
NetworkViz.Create = function(inNetwork)
{
	var obj = {};
	
	obj.Network = inNetwork;
	
	obj.JQ = {};
	obj.JQ.Canvas = $("<canvas></canvas>");
	obj.JQ.Canvas.attr({width:NetworkViz.Rasterization.Width*NetworkViz.Rasterization.Density, height:NetworkViz.Rasterization.Height*NetworkViz.Rasterization.Density});
	obj.JQ.Canvas.css({position:"absolute", left:-NetworkViz.Rasterization.Width/2+"px", top:-NetworkViz.Rasterization.Height/2+"px", width:NetworkViz.Rasterization.Width+"px", height:NetworkViz.Rasterization.Height+"px"});
	
	obj.Context = obj.JQ.Canvas.get(0).getContext("2d");
	
	obj.Iterator = function(inBitampX, inBitmapY, inScreenX, inScreenY)
	{
		Network.Observe(obj.Network, [inScreenX, inScreenY]);
		NetworkViz.Rasterization.SetColor(obj.Context, obj.Network.OutputLayer[0].Outputs.Linear, obj.Network.OutputLayer[1].Outputs.Linear, obj.Network.OutputLayer[2].Outputs.Linear, inBitampX, inBitmapY);
	};
	
	NetworkViz.JQ.Contianer.append(obj.JQ.Canvas);
	NetworkViz.Instances.push(obj);
	
	return obj;
};
NetworkViz.Update = function()
{
	var i;
	for(i=0; i<NetworkViz.Instances.length; i++)
	{
		NetworkViz.Rasterization.Iterate(NetworkViz.Instances[i].Iterator);
	}
};
</script>


<!-- setup -->
<script>
	/*
		buncha crap for setting up training vectors
	*/
	var TypeA = {};
	TypeA.CSS = "TypeA";
	TypeA.Vector = [1, 0, 0];
	
	var TypeB = {};
	TypeB.CSS = "TypeB";
	TypeB.Vector = [0, 1, 0];
	
	var TypeC = {};
	TypeC.CSS = "TypeC";
	TypeC.Vector = [0, 0, 1];
	
	function tv(inCoords, inType)
	{
		var t = TrainingVector.Create(inCoords, inType.Vector);
		TrainingVectorViz.Create(t, inType.CSS);
	}
	
	tv([-100, 50], TypeA);
	tv([-50, 80], TypeA);
	tv([-10, 70], TypeA);
	tv([20, 80], TypeA);
	tv([-100, -50], TypeA);
	tv([-50, -60], TypeA);
	tv([-10, -70], TypeA);
	tv([20, -80], TypeA);
	tv([150, 80], TypeA);
	
	tv([-180, 0], TypeB);
	tv([-120, 10], TypeB);
	tv([-50, -10], TypeB);
	tv([20, -20], TypeB);
	tv([50, 6], TypeB);
	tv([50, 100], TypeB);
	tv([20, 108], TypeB);
	tv([-5, 110], TypeB);
	tv([-20, -130], TypeB);
	tv([-30, -120], TypeB);
	
	tv([-200, -200], TypeC);
	tv([-210, -190], TypeC);
	tv([-208, -120], TypeC);
	tv([-150, 120], TypeC);
	tv([-130, 130], TypeC);
	
	
	/*
		Build the network.
		Note that layer 1's weights are spread out in that for loop
	*/
	var net1 = Network.Create(2);
	Network.AddLayer(net1, 200, 0.01);
	Network.AddLayer(net1, 50, 0.01);
	Network.AddLayer(net1, 10, 0.01);
	Network.AddLayer(net1, 3, 0.1);
	for(var i=0; i<net1.Layers[1].length; i++)
	{
		net1.Layers[1][i].Model.Bias *= 200;
	}
	NetworkViz.Create(net1);

	
	/*
		Update animation stuff
	*/
	var Time = {};
	Time.Running = true;
	Time.Interval = 10;
	Time.Count = 0;
	Time.Wrap = 30;
	Time.RoutineInner = function()
	{
		for(var i = 0; i<TrainingVector.Instances.length; i++)
		{
			Network.Observe(net1, TrainingVector.Instances[i].Pos);
			Network.Learn(net1, TrainingVector.Instances[i].Type);
		}
		if(Time.Count == 0)
			NetworkViz.Update();
	};
	Time.RoutineOuter = function()
	{
		Time.RoutineInner();
		if(Time.Running)
		{
			setTimeout(Time.RoutineOuter, Time.Interval);
			Time.Count++;
			Time.Count %= Time.Wrap;
		}
	};
	Time.Start = function()
	{
		Time.Running = true;
		Time.RoutineOuter();
	};
	Time.Stop = function()
	{
		Time.Running = false;
	};
	Time.Start();
	
	
</script>


</html>